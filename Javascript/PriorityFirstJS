1. জাভাস্ক্রিপ্ট সিংগেল থ্রেটেড না মাল্টিথ্রেটেড?
উত্তর:
জাভাস্ক্রিপ্ট একটি সিঙ্গেল থ্রেডেড ভাষা। এর মানে, এটি একবারে একটি কাজই করতে পারে। অর্থাৎ, জাভাস্ক্রিপ্ট একই সময়ে একটিমাত্র কাজ (task) সম্পন্ন করে।
Callstack and heap memory.

যদিও জাভাস্ক্রিপ্ট সিঙ্গেল থ্রেডেড, তবে এটি নন-ব্লকিং। 
JS Line by line code Execute 
এটি ইভেন্ট লুপ ব্যবহার করে অ্যাসিঙ্ক্রোনাস কাজ সম্পন্ন করে। যখন কোনো কাজ দীর্ঘ সময় নেয় (যেমন API কল বা টাইমার), তখন জাভাস্ক্রিপ্ট ঐ কাজটি অন্য একটি থ্রেডে পাঠায় এবং ইভেন্ট লুপ কাজটি সম্পন্ন হলে রেজাল্ট নিয়ে আসে। এতে অন্যান্য কাজগুলো থেমে থাকে না।




2. জাভাস্ক্রিপ্ট এর সাথে ব্যাকেন্ডে কেন নোড ইউস করব, অন্যগুলা কেন নয়?
উত্তর:
নোড.জেএস (Node.js) মূলত জাভাস্ক্রিপ্টকে ব্যাকএন্ড ডেভেলপমেন্টে ব্যবহার করার সুযোগ করে দেয়।

সিঙ্গেল-থ্রেডেড, নন-ব্লকিং আর্কিটেকচার:
নোড.জেএস-এর ইভেন্ট-ড্রিভেন, নন-ব্লকিং আর্কিটেকচার খুবই দ্রুত এবং স্কেলেবল।

জাভাস্ক্রিপ্টের ব্যবহার:
ফ্রন্টএন্ড এবং ব্যাকএন্ডে একই ভাষা (জাভাস্ক্রিপ্ট) ব্যবহার করে কোড লেখা যায়, এতে ডেভেলপারদের জন্য কাজ অনেক সহজ হয়ে যায়।

রিয়েল-টাইম অ্যাপ্লিকেশন:


অন্যগুলা কেন নয়:
বেশিরভাগ ব্যাকএন্ড ভাষা (যেমন Python, Java, PHP) মাল্টিথ্রেডেড হয় এবং সিনক্রোনাস কনসেপ্টের উপর ভিত্তি করে চলে। যদিও এগুলোও শক্তিশালী, তবে নির্দিষ্ট কিছু ক্ষেত্রে (যেমন, রিয়েল-টাইম অ্যাপ্লিকেশন বা স্কেলিং) নোড.জেএস অনেক বেশি কার্যকরী।



3. Difference between cluster and child process model
উত্তর:
Node.js-এর মধ্যে ক্লাস্টার (Cluster) এবং চাইল্ড প্রসেস (Child Process) দুটি আলাদা মডিউল, যেগুলো কিভাবে মেমোরি এবং CPU ব্যবহার করবে তা নির্ধারণ করে।

Child Process:
চাইল্ড প্রসেস মডিউল ব্যবহার করে একটি প্রোগ্রাম অন্য প্রোগ্রাম বা কোড এক্সিকিউট করতে পারে। মূলত চাইল্ড প্রসেস তৈরি করা হয় অন্য একটি নতুন প্রসেস চালানোর জন্য। 

Cluster:
ক্লাস্টার মডিউল ব্যবহার করে নোড.জেএস-এর মধ্যে একাধিক প্রসেস চালানো যায়। এটি একই সার্ভারে একাধিক থ্রেড তৈরি করে কাজ করার সুযোগ দেয়। বিশেষত, এটি নোড.জেএস এর সিঙ্গেল থ্রেডেড প্রকৃতিকে কাটিয়ে উঠতে সহায়তা করে এবং মাল্টি-কোর সিস্টেমের সুবিধা নেয়।

4. Call, Bind, Apply সম্পর্কে বলো ✅
উত্তর:
জাভাস্ক্রিপ্টে call, bind, এবং apply ফাংশনগুলি ব্যবহৃত হয় ফাংশনের কন্টেক্সট (this) পরিবর্তন করার জন্য। এগুলোর কাজ প্রায় একই, কিন্তু এদের ব্যবহারের ধরন আলাদা।

Call:
call() ফাংশন ব্যবহার করে তুমি একটি ফাংশনকে তাৎক্ষণিকভাবে কল করতে পারো এবং সেই সাথে এই ফাংশনের মধ্যে this এর ভ্যালু নির্ধারণ করতে পারো।

function greet() {
    console.log(`Hello, ${this.name}`);
}
const person = { name: 'Nur' };
greet.call(person); // Output: Hello, Nur


Apply:
apply() ফাংশনের কাজ call() এর মতোই, তবে এখানে আর্গুমেন্টগুলো একটি array এর মাধ্যমে পাস করতে হয়।

function greet(greeting) {
    console.log(`${greeting}, ${this.name}`);
}
const person = { name: 'Nur' };
greet.apply(person, ['Hi']); // Output: Hi, Nur


Bind:
bind() ফাংশনটি মূল ফাংশনের একটি নতুন কপি তৈরি করে এবং সেই ফাংশনের মধ্যে this এর ভ্যালু বেঁধে (bind) রাখে। এটি মূল ফাংশনকে তাৎক্ষণিকভাবে কল করে না বরং একটি নতুন ফাংশন রিটার্ন করে, যা পরবর্তীতে কল করা যেতে পারে।

function greet() {
    console.log(`Hello, ${this.name}`);
}
const person = { name: 'Nur' };
const greetPerson = greet.bind(person);
greetPerson(); // Output: Hello, Nur


5. This বলতে কি বুঝি, কাজ কি এটার? ✅
উত্তর:
জাভাস্ক্রিপ্টে this কীওয়ার্ড দিয়ে আমরা একটি অবজেক্টকে রেফার করি। এটি সেই অবজেক্টকে ইন্ডিকেট করে যার মধ্যে ফাংশনটি রান হচ্ছে।

this এর কাজ:

ফাংশনের কন্টেক্সট (অর্থাৎ, কোন অবজেক্টের সাথে ফাংশনটি সম্পর্কিত) নির্ধারণ করা।
ডাইনামিক্যালি পরিবর্তনশীল ফাংশনের ভেতরের অবজেক্টের সাথে কাজ করা।
উদাহরণ:

const person = {
    name: 'Nur',
    greet: function() {
        console.log(`Hello, ${this.name}`);
    }
};
person.greet(); // Output: Hello, Nur
এখানে this.name মূলত person অবজেক্টের name প্রপার্টিকে নির্দেশ করছে।


6. Callback and return এর পার্থক্য কি, দুইটা কাজ এক না আলাদা।
উত্তর:
জাভাস্ক্রিপ্টে callback এবং return দুটি আলাদা কনসেপ্ট।

Callback:
একটি callback হল ফাংশন, যা অন্য একটি ফাংশনের আর্গুমেন্ট হিসেবে পাস করা হয় এবং নির্দিষ্ট কিছু কাজ শেষে পরবর্তীতে এক্সিকিউট হয়। এটি মূলত asynchronous কার্যপদ্ধতির জন্য ব্যবহৃত হয়।

উদাহরণ:

function processUserInput(callback) {
    const name = "Nur";
    callback(name);
}

processUserInput(function(name) {
    console.log(`Hello, ${name}`);
});
এখানে callback ফাংশন হিসেবে পাস হয়েছে, এবং processUserInput কাজ শেষে সেটি কল করেছে।

Return:
একটি return স্টেটমেন্ট কোনো ফাংশনের এক্সিকিউশন থামিয়ে দিয়ে নির্দিষ্ট মান রিটার্ন করে। এটি synchronous কার্যপদ্ধতির জন্য ব্যবহৃত হয়।

উদাহরণ:

function add(a, b) {
    return a + b;
}

const sum = add(3, 4);
console.log(sum); // Output: 7
পার্থক্য:

callback asynchronous কাজের জন্য, যেখানে কাজ শেষ হলে ফাংশনটি পরবর্তীতে কল হয়।
return synchronous কাজের জন্য, যেখানে একটি মান ফাংশন থেকে তাৎক্ষণিকভাবে রিটার্ন করে।


7. Higher order Function কী? ✅
উত্তর:
Higher-order function বলতে এমন একটি ফাংশনকে বোঝায়, যা একটি ফাংশনকে আর্গুমেন্ট হিসেবে গ্রহণ করতে পারে অথবা অন্য একটি ফাংশনকে রিটার্ন করতে পারে। এই ধরনের ফাংশনগুলো জাভাস্ক্রিপ্টের অনেক শক্তিশালী বৈশিষ্ট্যকে তুলে ধরে।

উদাহরণ:

function higherOrder(fn) {
    fn();
}

function sayHello() {
    console.log("Hello, World!");
}

higherOrder(sayHello); // Output: Hello, World!

এখানে higherOrder একটি higher-order function কারণ এটি অন্য একটি ফাংশনকে আর্গুমেন্ট হিসেবে গ্রহণ করেছে।

কাজ:
Higher-order ফাংশনগুলো বিভিন্ন কাজে ব্যবহৃত হয়, যেমন map, filter, এবং reduce। এই ধরনের ফাংশনগুলো অ্যারে অথবা অবজেক্টের উপরে বিভিন্ন কার্যক্রম চালাতে পারে।

8. Event loop and Event queue এর পার্থক্য কি?
উত্তর:
জাভাস্ক্রিপ্ট event loop এবং event queue এর মাধ্যমে অ্যাসিঙ্ক্রোনাস কাজগুলো ম্যানেজ করে।

Event Loop:
Event loop হল একটি মেকানিজম যা মূলত কনকারেন্ট (concurrent) প্রোগ্রামিং সম্ভব করে। এটি মূলত কাজ করে call stack খালি কিনা তা দেখার মাধ্যমে। যখন call stack খালি থাকে, তখন event loop callback queue থেকে কাজগুলো নিয়ে call stack এ পুশ করে।

Event Queue (Callback Queue):
Event queue হল এমন একটি জায়গা যেখানে অ্যাসিঙ্ক্রোনাস কাজের পর callback ফাংশনগুলো একত্রিত থাকে। কাজগুলো একে একে call stack-এ পাঠানো হয়।

পার্থক্য:
Event loop মূলত নিরীক্ষা করে যে call stack খালি হয়েছে কিনা, আর event queue কাজগুলো জমা রাখে, যেন সেগুলো call stack খালি হলে প্রসেস করা যায়।




9. What is Data Type in JavaScript? ✅
উত্তর:
জাভাস্ক্রিপ্টে ডেটা টাইপ হল ভেরিয়েবল বা মানের ধরণ। এটি নির্ধারণ করে যে, কোনো ভেরিয়েবল কী ধরণের মান ধারণ করছে।

JavaScript এর প্রিমিটিভ ডেটা টাইপগুলো:

Number: সংখ্যা (উদাহরণ: 5, 3.14)
String: টেক্সট বা স্ট্রিং (উদাহরণ: "Hello", 'World')
Boolean: সত্য বা মিথ্যা (উদাহরণ: true, false)
Null: কোনো মান নাই
Undefined: ভেরিয়েবলের জন্য কোনো মান নির্ধারিত হয়নি
Symbol (ES6 থেকে): ইউনিক এবং ইমিউটেবল মান


Non-primitive data type:
Object: বিভিন্ন প্রোপার্টি ও মেথডের সমষ্টি (উদাহরণ: { name: "Nur" })


10. Undefine and Define variable কি?
উত্তর:

Undefined:
একটি ভেরিয়েবল যখন ডিক্লেয়ার করা হয় কিন্তু সেটিতে কোনো মান অ্যাসাইন করা হয়নি, তখন সেটি undefined থাকে।

উদাহরণ:

let x;
console.log(x); // Output: undefined


Defined:
যখন একটি ভেরিয়েবল ডিক্লেয়ার করার পর তাকে একটি নির্দিষ্ট মান অ্যাসাইন করা হয়, তখন সেটি defined বলে গণ্য হয়।

উদাহরণ:

let x = 10;
console.log(x); // Output: 10


11. Default parameters কি কেন ব্যাবহার করা হয়?
উত্তর:
ডিফল্ট প্যারামিটার হলো একটি প্যারামিটারের জন্য পূর্বনির্ধারিত মান যা ফাংশনে কোনো মান পাস না করা হলে ব্যবহার করা হয়। জাভাস্ক্রিপ্টের ES6 থেকে ডিফল্ট প্যারামিটার ফিচারটি যুক্ত করা হয়েছে। এটি মূলত তখন কাজে আসে যখন ফাংশন কল করার সময় কোনো আর্গুমেন্ট পাস না করা হয়, তবে ফাংশনটিকে তবুও একটি ডিফল্ট ভ্যালু দিয়ে কাজ করতে হবে।

কেন ব্যাবহার করা হয়:

যখন আমরা নিশ্চিত থাকি যে কোনো প্যারামিটারের একটি ডিফল্ট ভ্যালু থাকা উচিত, তখন এটি ব্যবহার করা হয়।
কোডের রিডেবিলিটি ও ব্যবস্থাপনা সহজ করে।
উদাহরণ:

function greet(name = "Guest") {
    console.log(`Hello, ${name}`);
}

greet(); // Output: Hello, Guest
greet("Nur"); // Output: Hello, Nur
এখানে, যদি greet() ফাংশনটি কোনো আর্গুমেন্ট ছাড়া কল করা হয়, তবে এটি ডিফল্ট মান হিসেবে "Guest" প্রিন্ট করবে।

12. “==” এবং “===” মধ্যে পার্থক্য আছে কিনা? ✅
উত্তর:
হ্যাঁ, == এবং === এর মধ্যে পার্থক্য রয়েছে।

== (Double equals):
ডাবল ইকুয়ালস শুধু মানের তুলনা করে। এটি ভিন্ন টাইপের মানকে একই রকম মনে করে তুলনা করে এবং প্রয়োজনে টাইপ কনভার্সন করে ফেলে। এটিকে type coercion বলে।

উদাহরণ:

console.log(5 == "5"); // Output: true
এখানে 5 এবং "5" এর টাইপ ভিন্ন (একটি সংখ্যা, একটি স্ট্রিং), কিন্তু ডাবল ইকুয়ালস টাইপ কনভার্ট করে শুধুমাত্র মানের তুলনা করে, তাই এটি true রিটার্ন করে।

=== (Triple equals):
ট্রিপল ইকুয়ালস মানের পাশাপাশি টাইপও চেক করে। যদি মান ও টাইপ উভয়ই একই না হয়, তবে এটি false রিটার্ন করবে।

উদাহরণ:

console.log(5 === "5"); // Output: false
এখানে, টাইপ ভিন্ন (একটি সংখ্যা এবং একটি স্ট্রিং), তাই ট্রিপল ইকুয়ালস false রিটার্ন করে।

পার্থক্য:

== শুধুমাত্র মানের তুলনা করে।
=== মান এবং টাইপ উভয়ের তুলনা করে।


13. Javascript scope, Block scope and Global scope, Lexical scope এর পার্থক্য
উত্তর:
জাভাস্ক্রিপ্টে স্কোপ বলতে বোঝায়, কোনো ভেরিয়েবল, ফাংশন বা অবজেক্ট কোন অংশে অ্যাক্সেস করা যাবে। বিভিন্ন প্রকারের স্কোপ রয়েছে:

Global Scope:
যখন কোনো ভেরিয়েবল বা ফাংশন স্কোপের বাইরের হয়, তখন সেটি global scope এর অন্তর্ভুক্ত। এটি পুরো স্ক্রিপ্ট বা কোড জুড়ে অ্যাক্সেসযোগ্য থাকে।

উদাহরণ:

let x = 10; // Global scope

function display() {
    console.log(x); // Accessing global variable
}

Block Scope:
Block scope সাধারণত {} এর মধ্যে থাকা কোড ব্লকের মধ্যে থাকে। let এবং const ব্লক স্কোপের জন্য কাজ করে, অর্থাৎ এগুলো শুধুমাত্র ঐ নির্দিষ্ট ব্লকের ভেতরেই অ্যাক্সেস করা যায়।

উদাহরণ:

if (true) {
    let y = 20;
    console.log(y); // Output: 20
}
console.log(y); // Error: y is not defined

Lexical Scope:
Lexical scope নির্ধারণ করে যে ফাংশনের ভেতরের ভেরিয়েবল কোথা থেকে অ্যাক্সেস করা যাবে। এটি ফাংশনের ভিতরের ও বাইরের স্কোপকে বোঝায়। জাভাস্ক্রিপ্টের ফাংশনগুলি তাদের ডিফাইন করা যায়গা থেকে উপরের স্কোপের অ্যাক্সেস পায়।

উদাহরণ:

function outer() {
    let outerVar = 'I am outer!';
    function inner() {
        console.log(outerVar); // Lexical scoping allows access to outerVar
    }
    inner();
}
outer(); // Output: I am outer!

14. Var, Let, Const মধ্যে সম্পর্ক এবং পার্থক্য কি? ✅
উত্তর:
জাভাস্ক্রিপ্টে var, let, এবং const ব্যবহার করে ভেরিয়েবল ডিক্লেয়ার করা হয়। এদের মধ্যে কিছু সম্পর্ক এবং পার্থক্য রয়েছে:

var:

ফাংশন স্কোপড (function-scoped), অর্থাৎ এটি শুধুমাত্র ফাংশনের মধ্যে স্কোপড।

Hoisting এর ফলে এটি ডিক্লেয়ারের আগে ব্যবহার করা সম্ভব, কিন্তু ডিফল্ট মান undefined থাকবে।

উদাহরণ:

console.log(a); // Output: undefined
var a = 10;


let:
ব্লক স্কোপড (block-scoped), অর্থাৎ এটি শুধুমাত্র {} এর মধ্যে স্কোপড।

Hoisting হয়, কিন্তু এটি টেম্পোরাল ডেড জোন (TDZ) এর কারণে ডিক্লেয়ারের আগে ব্যবহার করা যায় না।

উদাহরণ:

let b = 20;
if (true) {
    let b = 30;
    console.log(b); // Output: 30 (block-scoped)
}
console.log(b); // Output: 20
const:

ব্লক স্কোপড (block-scoped)।

একবার মান অ্যাসাইন করলে সেটি পরিবর্তন করা যায় না।

উদাহরণ:

const c = 40;
c = 50; // Error: Assignment to constant variable
পার্থক্য:

var ফাংশন স্কোপড, whereas let এবং const ব্লক স্কোপড।
const দিয়ে ডিক্লেয়ার করা ভেরিয়েবল পুনরায় অ্যাসাইন করা যায় না, কিন্তু let দিয়ে করা যায়।


15. Is Javascript Synchronous or asynchronous? How does it work?
উত্তর:
জাভাস্ক্রিপ্ট মূলত একটি সিঙ্গেল থ্রেডেড, সিঙ্ক্রোনাস ভাষা, অর্থাৎ এটি এক সময়ে একটিমাত্র কাজ করে। তবে এর মধ্যে অ্যাসিঙ্ক্রোনাস কার্যপদ্ধতিও রয়েছে যা ইভেন্ট লুপের মাধ্যমে পরিচালিত হয়।

How it works:

Synchronous:
সিঙ্ক্রোনাস কাজগুলো একটার পর একটা লাইন বাই লাইন এক্সিকিউট হয়। আগে যে কাজ শুরু হয়, সেটি সম্পন্ন না হওয়া পর্যন্ত অন্য কোনো কাজ শুরু হয় না।

উদাহরণ:

console.log("Start");
console.log("End");
// Output: 
// Start
// End


Asynchronous:
অ্যাসিঙ্ক্রোনাস কাজগুলো একাধিক কাজকে একই সময়ে প্রক্রিয়া করতে পারে। যেসব কাজ সম্পূর্ণ হতে সময় নেয় (যেমন API কল), সেগুলো সম্পন্ন হতে অন্য কাজগুলো প্রক্রিয়াতে অংশ নিতে পারে। জাভাস্ক্রিপ্টে এটি ইভেন্ট লুপের মাধ্যমে ঘটে।

উদাহরণ:

console.log("Start");

setTimeout(function() {
    console.log("This happens after 2 seconds");
}, 2000);

console.log("End");

// Output: 
// Start
// End
// This happens after 2 seconds
এখানে, যদিও setTimeout() ২ সেকেন্ড সময় নেয়, বাকি কাজগুলো থেমে থাকে না।


16. Ref. Type and preemptive type এর পার্থক্য কি?
উত্তর:
জাভাস্ক্রিপ্টে প্রিমিটিভ টাইপ (Primitive Type) এবং রেফারেন্স টাইপ (Reference Type) দুটি ভিন্ন ভিন্ন ধরণের ডেটা টাইপ।

Primitive Type:
প্রিমিটিভ টাইপগুলো সাধারণত single value ধারণ করে এবং সরাসরি ভ্যালু স্টোর করে। এগুলোর মধ্যে আছে:

Number (উদাহরণ: 10)
String (উদাহরণ: "Hello")
Boolean (উদাহরণ: true, false)
Null (একটি খালি মান)
Undefined (ভেরিয়েবল ডিক্লেয়ার হয়েছে কিন্তু কোনো মান অ্যাসাইন করা হয়নি)
Symbol (ইউনিক আইডেন্টিফায়ার)
উদাহরণ:

let a = 5;
let b = a; // a এর কপি b তে
a = 10;
console.log(b); // Output: 5 (b তে পরিবর্তন হয় না)


Reference Type:
রেফারেন্স টাইপগুলোতে ভ্যালু সরাসরি স্টোর হয় না, বরং ভ্যালুর মেমোরি লোকেশন (address) স্টোর হয়। এতে অবজেক্ট, অ্যারে, এবং ফাংশন অন্তর্ভুক্ত।

উদাহরণ:

let obj1 = { name: "Nur" };
let obj2 = obj1; // obj1 এর রেফারেন্স obj2 তে পাস হলো
obj1.name = "Muhammad";
console.log(obj2.name); // Output: "Muhammad" (রেফারেন্স শেয়ার হয়)
পার্থক্য:

Primitive Type: সরাসরি ভ্যালু ধারণ করে।
Reference Type: মেমোরি লোকেশন বা রেফারেন্স ধারণ করে, মানের পরিবর্তন হলে রেফারেন্স করা সব জায়গায় সেই পরিবর্তন প্রভাবিত হয়।


17. Es6 advance topic বলো, কোনগুলা ব্যাবহার করছো?
উত্তর:
ES6 (ECMAScript 2015) হল জাভাস্ক্রিপ্টের একটি মেজর আপডেট, যা অনেক নতুন ফিচার এনেছে। এর মধ্যে কয়েকটি advanced topics হলো:

Arrow Functions:
সাধারণ ফাংশনের চেয়ে ছোট এবং সহজ। this এর ব্যবহার সহজ করে।

const greet = () => console.log("Hello!");


Template Literals:
স্ট্রিং ইন্টারপোলেশন, মাল্টিলাইন স্ট্রিং ব্যবহারে সাহায্য করে।

let name = "Nur";
console.log(`Hello, ${name}`);


Destructuring Assignment:
অবজেক্ট বা অ্যারের মানগুলো সহজে এক্সট্র্যাক্ট করার উপায়।

let {name, age} = {name: "Nur", age: 13};


Spread and Rest Operators:
অ্যারে বা অবজেক্টকে এক্সপান্ড বা কম্প্রেস করার জন্য ব্যবহৃত হয়।

let arr = [1, 2, 3];
let newArr = [...arr, 4, 5];


Promises:
অ্যাসিঙ্ক্রোনাস অপারেশনের জন্য ব্যবহৃত হয়।

let promise = new Promise((resolve, reject) => {
    // some async task
});
ব্যবহার করেছি:
ES6 এর বেশিরভাগ ফিচার আমি ব্যবহার করেছি, বিশেষ করে arrow functions, template literals, spread/rest operators, এবং destructuring।

18. Prototype chain বলতে কি বোঝো?
উত্তর:
Prototype chain হল জাভাস্ক্রিপ্টের একটি প্রক্রিয়া, যেখানে একটি অবজেক্টের প্রোপার্টি বা মেথড অন্য অবজেক্ট থেকে ইনহেরিট করা যায়। জাভাস্ক্রিপ্টে প্রত্যেকটি অবজেক্টের একটি প্রোটোটাইপ থাকে এবং সেই প্রোটোটাইপের নিজস্ব আরেকটি প্রোটোটাইপ থাকতে পারে। এভাবেই চেইনের মাধ্যমে একটি অবজেক্টের প্রোটোটাইপ অন্য অবজেক্টের প্রোটোটাইপের সাথে যুক্ত হয়, যাকে prototype chain বলে।

কাজের ধরন:
যখন কোনো অবজেক্টের প্রোপার্টি বা মেথড অ্যাক্সেস করা হয়, তখন প্রথমে সেই অবজেক্টের প্রোপার্টি চেক করা হয়। যদি না পাওয়া যায়, তখন প্রোটোটাইপে খোঁজা হয়। এইভাবে এটি প্রোটোটাইপ চেইনের মাধ্যমে উপরের দিকে যেতে থাকে যতক্ষণ না পাওয়া যায়, অথবা প্রোটোটাইপ চেইনের শেষ (null) পর্যন্ত পৌঁছায়।

উদাহরণ:

function Person(name) {
    this.name = name;
}

Person.prototype.sayHello = function() {
    console.log(`Hello, my name is ${this.name}`);
};

let person1 = new Person("Nur");
person1.sayHello(); // Output: Hello, my name is Nur
এখানে, person1 অবজেক্টের প্রোটোটাইপ থেকে sayHello মেথডটি ইনহেরিট করা হয়েছে।

19. Pseudocode Method chaining নিয়ে কাজ করা হয় না।
উত্তর:
Method chaining হলো একাধিক মেথডকে একসাথে কল করার পদ্ধতি, যেখানে প্রত্যেকটি মেথডের আউটপুট সরাসরি পরবর্তী মেথডে ইনপুট হিসেবে পাস হয়। এটি মূলত fluent interface ডিজাইন প্যাটার্নের একটি অংশ।

কাজের ধরন:
প্রত্যেক মেথডের শেষে this রিটার্ন করতে হয়, যাতে সেটি পরবর্তী মেথড কল করতে পারে। মেথড চেইনিং কোডের রিডেবিলিটি বাড়ায়।

উদাহরণ:

let str = "hello";
str = str.toUpperCase().split("").reverse().join("");
console.log(str); // Output: OLLEH
এখানে একাধিক মেথড একের পর এক চেইন করা হয়েছে।

20. How many arguments does call, apply, bind take? ✅
উত্তর:
call, apply, এবং bind মেথড তিনটি ফাংশনের কনটেক্সট (this) পরিবর্তন করার জন্য ব্যবহৃত হয়, কিন্তু এদের আর্গুমেন্ট নেওয়ার পদ্ধতি ভিন্ন।

call:
call মেথডে প্রথম আর্গুমেন্ট হিসেবে this কনটেক্সট পাস করা হয় এবং বাকি আর্গুমেন্টগুলো আলাদা আলাদা করে পাস করতে হয়।

function greet(greeting, name) {
    console.log(`${greeting}, ${name}`);
}
greet.call(null, "Hello", "Nur"); // Output: Hello, Nur
apply:
apply মেথডেও প্রথম আর্গুমেন্ট this কনটেক্সট পাস করা হয়, তবে বাকি আর্গুমেন্টগুলো অ্যারে আকারে পাস করতে হয়।

greet.apply(null, ["Hello", "Nur"]); // Output: Hello, Nur
bind:
bind মেথড একটি নতুন ফাংশন রিটার্ন করে, যেখানে this কনটেক্সট ও আর্গুমেন্টগুলো প্রি-সেট করা থাকে। এটি সাথে সাথে কল হয় না, বরং পরে কল করা হয়।

let greetNur = greet.bind(null, "Hello", "Nur");
greetNur(); // Output: Hello, Nur
পার্থক্য:

call: আর্গুমেন্ট আলাদা আলাদা করে নেয়।
apply: আর্গুমেন্ট অ্যারে আকারে নেয়।
bind: নতুন ফাংশন রিটার্ন করে, আর্গুমেন্টগুলো প্রি-সেট থাকে।


21. Event bubbling in JavaScript ✅
উত্তর:
Event bubbling হল জাভাস্ক্রিপ্টের ইভেন্ট হ্যান্ডলিং প্রক্রিয়ার একটি অংশ, যেখানে কোনো ইভেন্ট যখন একটি ইননার এলিমেন্টে ঘটে, তখন সেই ইভেন্টটি ইননার এলিমেন্ট থেকে শুরু করে তার প্যারেন্ট, প্যারেন্টের প্যারেন্ট ইত্যাদি সব প্যারেন্ট এলিমেন্টের কাছে পাঠানো হয়। অর্থাৎ, ইভেন্টটি বটম টু টপ (নীচ থেকে উপরে) নির্দেশে বুদবুদ আকারে ঊর্ধ্বমুখী হয়।

উদাহরণ:

html
Copy code
<div id="parent">
    <button id="child">Click Me</button>
</div>

<script>
document.getElementById("parent").addEventListener("click", function() {
    console.log("Parent clicked");
});

document.getElementById("child").addEventListener("click", function() {
    console.log("Child clicked");
});
</script>
যদি বাটনটি ক্লিক করা হয়, তাহলে আউটপুট হবে:

Copy code
Child clicked
Parent clicked
এখানে, ইভেন্ট প্রথমে চাইল্ড এলিমেন্টে ঘটে, তারপর সেটি প্যারেন্টে "বাবল" হয়।

22. Call by value vs Call by reference
উত্তর:
জাভাস্ক্রিপ্টে Call by value এবং Call by reference এর মাধ্যমে ফাংশনে আর্গুমেন্ট পাস করা হয়, কিন্তু এদের মধ্যে পার্থক্য আছে।

Call by value (মান দ্বারা ডাকা):
প্রিমিটিভ টাইপের ডেটা যখন ফাংশনে পাস করা হয়, তখন আসল ভ্যালুর একটি কপি ফাংশনে পাস করা হয়। এটি ক্লোনিং এর মতো কাজ করে এবং আসল ভ্যালুতে কোনো পরিবর্তন আনে না।

উদাহরণ:

let num = 10;
function modifyValue(value) {
    value = 20;
}
modifyValue(num);
console.log(num); // Output: 10 (num অপরিবর্তিত থাকে)


Call by reference (রেফারেন্স দ্বারা ডাকা):
অবজেক্ট বা অ্যারে রেফারেন্স টাইপের ডেটা হলে, তার রেফারেন্স ফাংশনে পাস করা হয়। এর ফলে আসল ডেটা পরিবর্তন হতে পারে, কারণ ফাংশন একই রেফারেন্স ব্যবহার করে কাজ করে।

উদাহরণ:

let obj = { value: 10 };
function modifyObject(o) {
    o.value = 20;
}
modifyObject(obj);
console.log(obj.value); // Output: 20 (obj পরিবর্তিত হয়)
পার্থক্য:

Call by value: আসল ভ্যালু পরিবর্তন হয় না।
Call by reference: আসল ডেটা পরিবর্তিত হতে পারে।

23. JavaScript hoisting, How many types of hoisting in JavaScript?
উত্তর:
Hoisting হল জাভাস্ক্রিপ্টের একটি মেকানিজম, যেখানে ভেরিয়েবল এবং ফাংশনের ডিক্লারেশন স্বয়ংক্রিয়ভাবে স্ক্রিপ্টের উপরের দিকে সরানো হয়। অর্থাৎ, কোড এক্সিকিউট করার আগে ভেরিয়েবল ও ফাংশনগুলোর ডিক্লারেশন (মান অ্যাসাইন না) উপরের দিকে নিয়ে যায়।

দুই প্রকারের Hoisting:

Variable Hoisting:
শুধুমাত্র ভেরিয়েবল ডিক্লারেশন উপরে ওঠে, কিন্তু ভ্যালু অ্যাসাইনমেন্ট নয়।

console.log(a); // Output: undefined
var a = 10;

Function Hoisting:
পুরো ফাংশন ডিক্লারেশন উপরে ওঠে।

greet(); // Output: Hello!
function greet() {
    console.log("Hello!");
}
উদাহরণ:

console.log(x); // Output: undefined
var x = 5;
এখানে, var x ডিক্লেয়ারেশনটি উপরে ওঠানো হয়, কিন্তু অ্যাসাইনমেন্ট পরে হয়, ফলে আউটপুট হবে undefined।

24. Function and recursive function কাকে বলে?
উত্তর:

Function (ফাংশন):
জাভাস্ক্রিপ্টে ফাংশন হল এক ধরনের ব্লক, যা নির্দিষ্ট কিছু কাজ সম্পন্ন করার জন্য কোডের একটি অংশকে encapsulate করে। ফাংশনকে বারবার ব্যবহার করা যায়, এবং এটি ডিফাইন্ড হওয়ার পরে যতবার খুশি কল করা যায়।

উদাহরণ:

function greet() {
    console.log("Hello, World!");
}
greet(); // Output: Hello, World!


Recursive Function (পুনরাবৃত্তি ফাংশন):
Recursive function এমন একটি ফাংশন, যা নিজেই নিজেকে কল করে। এটি সাধারণত কোনো সমস্যা সমাধানের জন্য ব্যবহার হয়, যেখানে বড় সমস্যা ছোট সমস্যায় বিভক্ত হয়ে একাধিকবার সমাধান করতে হয়।

উদাহরণ:

function factorial(n) {
    if (n === 0) return 1;
    return n * factorial(n - 1);
}
console.log(factorial(5)); // Output: 120

এখানে factorial ফাংশনটি নিজেই নিজেকে কল করে যতক্ষণ না n === 0 হয়।

25. How Spread operator works ✅
উত্তর:
Spread operator হলো জাভাস্ক্রিপ্টে ... চিহ্ন, যা একটি অ্যারে বা অবজেক্টকে তার উপাদানগুলোতে বিস্তৃত করে (spread) দেয়। এটি ES6 এ পরিচিতি লাভ করে।

ব্যবহার:

অ্যারে বা অবজেক্ট ক্লোন করার জন্য
স্প্রেড অপারেটরের মাধ্যমে একটি অ্যারের কপি বা ক্লোন করা যায়।

let arr1 = [1, 2, 3];
let arr2 = [...arr1]; // arr2 হল arr1 এর কপি
অ্যারে বা অবজেক্ট মার্জ করার জন্য
একাধিক অ্যারে বা অবজেক্ট মার্জ করার জন্য স্প্রেড ব্যবহার করা হয়।

let arr1 = [1, 2];
let arr2 = [3, 4];
let merged = [...arr1, ...arr2]; // Output: [1, 2, 3, 4]
অ্যারের উপাদানগুলোর সাথে অন্যান্য উপাদান যোগ করার জন্য

let arr = [1, 2, ...[3, 4], 5];
console.log(arr); // Output: [1, 2, 3, 4, 5]
স্প্রেড অপারেটর অ্যারের ভেতরের উপাদানগুলোকে এক্সপান্ড করতে বা মিশ্রিত করতে পারে। এটি অবজেক্টের ক্ষেত্রেও প্রযোজ্য।


26. Closure কী? Closure কিভাবে কাজ করে? ✅
উত্তর:
Closure হল একটি ফাংশন যা অন্য একটি ফাংশনের ভেতরে তৈরি হয় এবং সেই বাইরের ফাংশনের ভেরিয়েবল বা প্রোপার্টির এক্সেস করতে পারে, এমনকি যখন বাইরের ফাংশনটি এক্সিকিউট হওয়া শেষ হয়ে যায় তখনও।

কিভাবে কাজ করে:
যখন একটি ইননার ফাংশন কোনো বাইরের ফাংশনের ভেরিয়েবল ব্যবহার করে, তখন সেই ভেরিয়েবলের সাথে ইননার ফাংশনের একটি "ক্লোজার" তৈরি হয়। এর ফলে, বাইরের ফাংশন সম্পূর্ণ হওয়ার পরেও ইননার ফাংশন সেই ভেরিয়েবলগুলোতে অ্যাক্সেস করতে পারে।

উদাহরণ:

function outerFunction() {
    let outerVar = "I'm from outer function";

    function innerFunction() {
        console.log(outerVar); // ক্লোজারের মাধ্যমে outerVar অ্যাক্সেস করে
    }

    return innerFunction;
}

const inner = outerFunction();
inner(); // Output: I'm from outer function

এখানে, outerFunction এক্সিকিউট হওয়ার পরেও innerFunction বাইরের ভেরিয়েবল outerVar অ্যাক্সেস করতে পারছে। এটাই হলো ক্লোজারের মূল মেকানিজম।

27. JavaScript Inheritance কী?
উত্তর:
Inheritance (উত্তরাধিকার) হল একটি প্রক্রিয়া, যেখানে একটি অবজেক্ট অন্য একটি অবজেক্টের প্রোপার্টি এবং মেথড ইনহেরিট (পাওয়া) করে। জাভাস্ক্রিপ্টে এটি প্রোটোটাইপ চেইন এর মাধ্যমে কাজ করে। ইনহেরিট্যান্সের মাধ্যমে আমরা একটি ক্লাস বা অবজেক্ট থেকে নতুন ক্লাস বা অবজেক্ট তৈরি করতে পারি এবং আগের সব ফিচারগুলো নতুনটিতে যোগ করতে পারি।

উদাহরণ:

function Parent(name) {
    this.name = name;
}

Parent.prototype.greet = function() {
    console.log(`Hello, I am ${this.name}`);
};

function Child(name, age) {
    Parent.call(this, name); // Parent এর constructor ইনহেরিট করা
    this.age = age;
}

Child.prototype = Object.create(Parent.prototype); // প্রোটোটাইপ ইনহেরিট
Child.prototype.constructor = Child;

let child1 = new Child("Nur", 13);
child1.greet(); // Output: Hello, I am Nur
এখানে, Child অবজেক্টটি Parent এর প্রোপার্টি এবং মেথড ইনহেরিট করেছে।

28. একটা ফাংশনকে কখন রিটার্ন করতে হয়?
উত্তর:
একটি ফাংশনকে তখনই রিটার্ন করা হয় যখন আমরা ফাংশনটি এক্সিকিউট করে কোনো ভ্যালু ফেরত দিতে চাই। ফাংশনের কাজ শেষ হলে, return স্টেটমেন্ট দিয়ে আমরা ফাংশন থেকে নির্দিষ্ট কোনো মান ফিরিয়ে দিতে পারি, যা ফাংশন কল করার সময় কাজে লাগানো যায়।

কাজের ধরন:

কোনো মান রিটার্ন করা:

function add(a, b) {
    return a + b; // ফাংশন শেষে রিটার্ন করা হচ্ছে
}

let sum = add(5, 3);
console.log(sum); // Output: 8
ফাংশনকে প্রিম্যাচারলি বন্ধ করা:
কোনো শর্ত পূরণ হলে, ফাংশনকে বন্ধ করতে return স্টেটমেন্ট ব্যবহার করা যায়।

function checkPositive(num) {
    if (num < 0) return "Negative number"; // ফাংশন এখানেই থেমে যায়
    return "Positive number";
}

console.log(checkPositive(-5)); // Output: Negative number


29. Have any idea of Object-Oriented Programming (OOP)?
উত্তর:
Object-Oriented Programming (OOP) হল প্রোগ্রামিংয়ের একটি প্যারাডাইম, যেখানে ডেটা এবং তার সাথে সম্পর্কিত ফাংশনগুলোকে অবজেক্ট আকারে সংগঠিত করা হয়। OOP এর প্রধান চারটি বৈশিষ্ট্য হলো:

Encapsulation:
ডেটা এবং ফাংশনগুলোকে একটি অবজেক্টে সংরক্ষণ করে এবং বাইরের থেকে প্রাইভেট রাখা হয়।

class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
}

Abstraction:
অবজেক্টের শুধুমাত্র প্রয়োজনীয় বৈশিষ্ট্যগুলো প্রকাশ করা হয়, বাকিগুলো আড়াল করা হয়।

class Car {
    start() {
        // ইঞ্জিন স্টার্ট করার লজিক
    }
}


Inheritance:
একটি ক্লাস অন্য ক্লাস থেকে প্রোপার্টি এবং মেথড ইনহেরিট করতে পারে।

class Animal {
    makeSound() {
        console.log("Animal sound");
    }
}

class Dog extends Animal {
    makeSound() {
        console.log("Bark");
    }
}

Polymorphism:
একই নামের ফাংশন বিভিন্নভাবে কাজ করতে পারে, যা ক্লাসের ভিন্ন ধরনের আচরণ তৈরি করে।

let dog = new Dog();
dog.makeSound(); // Output: Bark

30. After writing a JavaScript code, how it will run in the browser step by step procedure?
উত্তর:
ব্রাউজারে জাভাস্ক্রিপ্ট কোড এক্সিকিউশন সাধারণত নিম্নলিখিত ধাপগুলোতে ঘটে:

HTML লোডিং:
ব্রাউজার প্রথমে HTML ফাইলটি লোড করে এবং DOM তৈরি করে।

JavaScript লোডিং:
HTML ফাইলের <script> ট্যাগে থাকা জাভাস্ক্রিপ্ট ফাইল লোড করা হয়।

Parsing & Compilation:
ব্রাউজার জাভাস্ক্রিপ্ট ইঞ্জিন (যেমন V8) ব্যবহার করে স্ক্রিপ্ট ফাইলটিকে পার্স করে

Execution Context তৈরি:
ইঞ্জিন গ্লোবাল এক্সিকিউশন কন্টেক্সট তৈরি করে, যেখানে স্কোপ চেইন, ভেরিয়েবল, ফাংশন এবং অবজেক্টগুলো সংরক্ষণ করা হয়।

Hoisting:
কোড এক্সিকিউশন শুরুর আগে, ভেরিয়েবল ও ফাংশন ডিক্লারেশনগুলো হোইস্ট করা হয়।

Code Execution:
কোডের প্রতিটি লাইন সিকোয়েন্স অনুযায়ী এক্সিকিউট করা হয়। এই সময়ে, অ্যাসিঙ্ক্রোনাস অপারেশন হলে ইভেন্ট লুপ কার্যকর হয়।

Rendering:
শেষ পর্যন্ত কোড সম্পন্ন হলে, DOM আবার রেন্ডার হয় এবং ব্রাউজার আউটপুট প্রদর্শন করে।

উদাহরণ:

html
Copy code
<!DOCTYPE html>
<html>
<head>
    <title>Test</title>
    <script>
        console.log("Hello, World!");
    </script>
</head>
<body>
    <p>JavaScript Example</p>
</body>
</html>
এই ধাপগুলো অনুসারে কোডটি প্রথমে HTML লোড হবে, তারপর জাভাস্ক্রিপ্ট এক্সিকিউট হবে এবং শেষে আউটপুট কনসোলে দেখা যাবে।


31. How to work push and pop method?
উত্তর:
জাভাস্ক্রিপ্টে push এবং pop মেথডগুলি অ্যারে-তে ব্যবহৃত হয় এবং এগুলি অ্যারের উপাদানগুলো ম্যানিপুলেট করার জন্য কার্যকর।

push():
এটি একটি মেথড, যা অ্যারের শেষে একটি বা একাধিক নতুন এলিমেন্ট যোগ করে। এটি নতুন অ্যারের দৈর্ঘ্য রিটার্ন করে।

উদাহরণ:

let arr = [1, 2, 3];
arr.push(4); // Output: [1, 2, 3, 4]

pop():
এটি একটি মেথড, যা অ্যারের শেষ উপাদানটি সরিয়ে ফেলে এবং সেই উপাদানটি রিটার্ন করে।

উদাহরণ:

let arr = [1, 2, 3, 4];
let lastElement = arr.pop(); // Output: [1, 2, 3]
console.log(lastElement); // Output: 4
মোট কথা:

push() অ্যারের শেষে উপাদান যোগ করে।
pop() অ্যারের শেষ উপাদানটি সরিয়ে ফেলে।


32. array vs linked list সম্পর্কে ধারণা আছে কিনা? দুটোর মধ্যে সম্পর্ক বা পার্থক্য কী?
উত্তর:
Array এবং Linked List উভয়ই ডেটা স্ট্রাকচার, তবে এদের মধ্যে বেশ কিছু মৌলিক পার্থক্য রয়েছে।

Array (অ্যারে):
অ্যারে হল একটি স্ট্যাটিক ডেটা স্ট্রাকচার, যেখানে নির্দিষ্ট আকারের ডেটা সংরক্ষণ করা হয়। প্রতিটি উপাদান অ্যারের মধ্যে একটি নির্দিষ্ট ইনডেক্স অনুযায়ী রাখা হয়।

উদাহরণ:

let arr = [10, 20, 30, 40]; // প্রতিটি উপাদানের ইনডেক্স আছে


Linked List (লিংকড লিস্ট):
লিংকড লিস্ট একটি ডায়নামিক ডেটা স্ট্রাকচার, যেখানে প্রতিটি উপাদান একটি নোড হিসেবে সংরক্ষিত হয়। প্রতিটি নোডে দুটি অংশ থাকে—ডেটা এবং পরবর্তী নোডের রেফারেন্স।

উদাহরণ:

class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

let node1 = new Node(10);
let node2 = new Node(20);
node1.next = node2; // লিংকড লিস্টের পরের নোডে রেফারেন্স যুক্ত করা হয়
পার্থক্য:

অ্যারে ফিক্সড সাইজ এবং ইনডেক্স ভিত্তিক, যেখানে লিংকড লিস্ট ডায়নামিক এবং প্রতিটি নোডে রেফারেন্স থাকে।
অ্যারেতে ইনডেক্সের মাধ্যমে উপাদান এক্সেস করা সহজ, কিন্তু লিংকড লিস্টে প্রতিটি নোডে পৌঁছতে হলে ক্রমান্বয়ে যেতে হয়।
অ্যারেতে ইনসার্ট বা ডিলিট করা সময়সাপেক্ষ, কিন্তু লিংকড লিস্টে ইনসার্ট বা ডিলিট করা সহজ।


33. class vs object মধ্যে সম্পর্ক কী?
উত্তর:
Class এবং Object উভয়ই জাভাস্ক্রিপ্টের Object-Oriented Programming (OOP) এর গুরুত্বপূর্ণ অংশ। এদের মধ্যে সম্পর্ক:

Class (ক্লাস):
ক্লাস হলো একটি টেমপ্লেট বা ব্লুপ্রিন্ট, যা থেকে অবজেক্ট তৈরি করা হয়। ক্লাসে ডেটা (প্রোপার্টি) এবং ফাংশন (মেথড) ডিফাইন করা হয়, যা পরবর্তী অবজেক্টের মধ্যে যুক্ত করা যায়।

Object (অবজেক্ট):
অবজেক্ট হলো ক্লাসের একটি ইনস্ট্যান্স। অর্থাৎ, ক্লাস থেকে একটি নির্দিষ্ট অবজেক্ট তৈরি হয়, যা সেই ক্লাসের সমস্ত প্রোপার্টি ও মেথড ব্যবহার করতে পারে।

উদাহরণ:

class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name}`);
    }
}

let person1 = new Person("Nur", 13); // Person ক্লাস থেকে অবজেক্ট তৈরি
person1.greet(); // Output: Hello, my name is Nur
মোট কথা:

Class একটি ব্লুপ্রিন্ট, যা অবজেক্ট তৈরি করতে ব্যবহৃত হয়।
Object হলো সেই ব্লুপ্রিন্ট থেকে তৈরি একটি নির্দিষ্ট ইনস্ট্যান্স, যা প্রোপার্টি ও মেথড ব্যবহার করে।


34. Object-oriented programming vs Functional programming, principles of object-oriented programming
উত্তর:
Object-Oriented Programming (OOP) এবং Functional Programming (FP) প্রোগ্রামিংয়ের দুটি ভিন্ন পদ্ধতি।

Object-Oriented Programming (OOP):
OOP এ, ডেটা এবং ফাংশনগুলোকে একসঙ্গে অবজেক্ট হিসেবে সংগঠিত করা হয়। এতে চারটি প্রধান বৈশিষ্ট্য রয়েছে:

Encapsulation: ডেটা এবং ফাংশনগুলিকে অবজেক্টের মধ্যে বন্ধ রাখা হয়।
Inheritance: একটি ক্লাস অন্য একটি ক্লাস থেকে প্রোপার্টি এবং মেথড ইনহেরিট করতে পারে।
Polymorphism: একাধিক ফাংশন একই নামে কাজ করতে পারে, ভিন্ন ধরনের আচরণ দেখাতে পারে।
Abstraction: কমপ্লেক্স ডেটা আড়াল করে শুধুমাত্র প্রয়োজনীয় জিনিসগুলো প্রকাশ করা হয়।

Functional Programming (FP):
FP এ, প্রোগ্রামিং করা হয় ফাংশন দিয়ে, এবং স্টেট পরিবর্তন করা হয় না। এখানে ফাংশনগুলোকে pure function বলা হয়, কারণ তারা কোনো এক্সটার্নাল ডেটার উপর নির্ভর করে না এবং স্টেট পরিবর্তন করে না।

FP এর বৈশিষ্ট্য:

Pure functions: একই ইনপুট সবসময় একই আউটপুট দেয়।
Immutability: কোনো স্টেট পরিবর্তন করা হয় না, নতুন ডেটা তৈরি হয়।
First-class functions: ফাংশনগুলোকে ডেটার মতো ট্রিট করা হয়, অর্থাৎ ফাংশনগুলোকে পাস করা যায়, রিটার্ন করা যায়, এমনকি স্টোরও করা যায়।
মোট কথা:

OOP তে অবজেক্ট ও তার স্টেটের উপর কাজ করা হয়।
FP তে ফাংশন ও তার ইনপুট আউটপুট নিয়ে কাজ করা হয়।

35. Why is JavaScript faster even though it is single-threaded?
উত্তর:
জাভাস্ক্রিপ্ট single-threaded, অর্থাৎ এটি একসাথে একাধিক কাজ করতে পারে না। কিন্তু তারপরও এটি দ্রুত কাজ করতে পারে কারণ:

Non-blocking I/O:
জাভাস্ক্রিপ্ট I/O অপারেশনগুলো (যেমন নেটওয়ার্ক রিকোয়েস্ট, ফাইল সিস্টেম রিড) non-blocking করে। অর্থাৎ, এগুলো ব্যাকগ্রাউন্ডে চলে এবং ইভেন্ট লুপ ব্যবহার করে কাজ সমাপ্ত হলে পরবর্তী কাজগুলো চালায়।

Event Loop:
ইভেন্ট লুপের মাধ্যমে জাভাস্ক্রিপ্ট অনেক কাজকে একসাথে পরিচালনা করতে পারে। যখন কোনো অ্যাসিঙ্ক্রোনাস অপারেশন শেষ হয়, তখন ইভেন্ট লুপ সেই কাজকে আবার মূল থ্রেডে ফিরিয়ে আনে এবং এক্সিকিউট করে।

V8 JavaScript Engine:
গুগলের V8 ইঞ্জিন জাভাস্ক্রিপ্টকে JIT (Just-in-Time) কম্পাইলিং করে, অর্থাৎ কোড রান করার সময় ইন্টারপ্রেটেড এবং কম্পাইলড দুই ধরণের পারফরম্যান্স একসঙ্গে কাজ করে, যা একে দ্রুত করে তোলে।

Optimized for Web:
জাভাস্ক্রিপ্টকে বিশেষভাবে ওয়েবের জন্য অপটিমাইজ করা হয়েছে, তাই এটি দ্রুত এবং এফিশিয়েন্ট।


36. Explain Method chaining.
উত্তর:
Method chaining হলো জাভাস্ক্রিপ্টের একটি টেকনিক, যা ব্যবহার করে একাধিক মেথডকে এক লাইন কোডে চেইন করা যায়। এটি সাধারণত তখন করা হয়, যখন প্রতিটি মেথডের আউটপুট সেই অবজেক্টটিকেই রিটার্ন করে, যাতে অন্য মেথডগুলো একই অবজেক্টে এক্সিকিউট হতে পারে।

উদাহরণ:
ধরা যাক, আমরা একটি Calculator ক্লাস তৈরি করেছি, যেখানে add(), subtract(), এবং multiply() মেথড রয়েছে। প্রত্যেকটি মেথডই ক্লাসের ইনস্ট্যান্সকে রিটার্ন করে।

class Calculator {
    constructor(value = 0) {
        this.value = value;
    }

    add(num) {
        this.value += num;
        return this;
    }

    subtract(num) {
        this.value -= num;
        return this;
    }

    multiply(num) {
        this.value *= num;
        return this;
    }

    printResult() {
        console.log(this.value);
        return this;
    }
}

let calc = new Calculator();
calc.add(5).subtract(2).multiply(3).printResult(); // Output: 9
মোট কথা:

মেথড চেইনিংয়ের মাধ্যমে কোডকে সংক্ষিপ্ত ও সুন্দরভাবে লেখা যায়।
প্রতিটি মেথডকে ওই অবজেক্ট রিটার্ন করতে হবে, যাতে চেইনিং করা যায়।





You said:
Okay trillion thanks for you
আপনাকেও ট্রিলিয়ন ধন্যবাদ! 😊 যদি আরও কোনও প্রশ্ন থাকে বা সাহায্য প্রয়োজন হয়, নিশ্চয়ই জানাবেন! আপনার ইন্টারভিউ প্রস্তুতির জন্য শুভকামনা!




================================================================================================================================================================================


1. JavaScript এবং ECMAScript এর মধ্যে কি পার্থক্য এবং কিভাবে তারা সম্পর্কিত?
উত্তর:
ECMAScript একটি স্ট্যান্ডার্ড স্ক্রিপ্টিং ভাষা যা জাভাস্ক্রিপ্টের জন্য ভিত্তি তৈরি করে। ECMAScript এর ভার্সনগুলো যেমন ECMAScript 5 (ES5), ECMAScript 6 (ES6), ইত্যাদি জাভাস্ক্রিপ্টের নতুন ফিচার ও ফাংশনালিটি সংযুক্ত করে।
JavaScript হলো ECMAScript এর বাস্তবায়ন (implementation) যা ব্রাউজার এবং অন্যান্য পরিবেশে ব্যবহৃত 

পার্থক্য:
ECMAScript হলো একটি স্পেসিফিকেশন যা ডিফাইন করে জাভাস্ক্রিপ্ট কিভাবে কাজ করবে।
JavaScript হলো সেই স্পেসিফিকেশনের ওপর ভিত্তি করে তৈরি করা একটি ভাষা যা বাস্তবে ব্রাউজারে ব্যবহৃত হয়।


2. Closure কি এবং কিভাবে Lexical Scope-এর সাথে সম্পর্কিত?
উত্তর:
Closure হলো একটি ফাংশন যা তার আশেপাশের স্কোপ থেকে ভ্যারিয়েবল অ্যাক্সেস করতে পারে, এমনকি যখন সেই ফাংশনটি সেই স্কোপের বাইরে কল করা হয়।
Lexical Scope বলতে ফাংশন যেখান থেকে ডিফাইন করা হয়, সেই স্কোপকে বোঝায়। Closure Lexical Scope-এর কারণে কাজ করে, কারণ যখন একটি ফাংশন তৈরি হয়, তখন এটি তার চারপাশের স্কোপকে মনে রাখে এবং ভবিষ্যতে সেই ভ্যারিয়েবলগুলো অ্যাক্সেস করতে পারে।
উদাহরণ:

function outer() {
  let outerVar = "I am outside!";
  function inner() {
    console.log(outerVar); // Closure: accessing outerVar from outer scope
  }
  return inner;
}
const closureFunc = outer();
closureFunc(); // Output: I am outside!


3. Callback Functions কি, এবং JavaScript-এ Asynchronous Programming এর ভূমিকা কি?
উত্তর:
Callback Function হলো একটি ফাংশন যা অন্য একটি ফাংশনকে আর্গুমেন্ট হিসেবে পাঠানো হয় এবং নির্দিষ্ট শর্ত পূরণ হলে তা পরবর্তীতে এক্সিকিউট হয়।
Asynchronous Programming-এ callback ফাংশন খুবই গুরুত্বপূর্ণ কারণ এটি কোডকে ব্লক না করে বিভিন্ন টাস্ক সম্পন্ন করতে সাহায্য করে। উদাহরণস্বরূপ, ডেটা ফেচ করার সময় callback ফাংশন ব্যবহার করা হয়, যেখানে ডেটা আসার পর callback ফাংশনটি এক্সিকিউট হয়।
উদাহরণ:

function fetchData(callback) {
  setTimeout(() => {
    console.log("Data fetched");
    callback();
  }, 2000);
}

fetchData(() => {
  console.log("Processing data");
});


4. JavaScript এবং ECMAScript-6 এর মধ্যে var, let, এবং const এর মধ্যে কি পার্থক্য এবং কীভাবে তাদের ব্যবহার করা হয়?
উত্তর:
var, let, const তিনটি ভ্যারিয়েবল ডিক্লারেশনের উপায়, কিন্তু তাদের স্কোপ এবং ব্যবহারে পার্থক্য রয়েছে।

var:
Function-scoped, মানে এটি ফাংশনের ভেতর ডিফাইন করলে পুরো ফাংশন জুড়ে এক্সেস করা যায়।
Hoisting করে, মানে ডিক্লারেশনের আগে এটি undefined হয়।
পুনরায় ডিক্লার করা যায়।
let:
Block-scoped, অর্থাৎ যে ব্লকের মধ্যে ডিফাইন করা হয়েছে, শুধু সেই ব্লকের মধ্যেই এক্সেস করা যাবে।
Hoisting করে না।
পুনরায় ডিক্লার করা যায় না।
const:
Block-scoped, এবং ভ্যালু পরিবর্তন করা যায় না।
Hoisting করে না।
ব্যবহার:

var এর পরিবর্তে let ও const ব্যবহার করা উত্তম, কারণ এটি ব্লক স্কোপিং করে এবং ভ্যারিয়েবলের আকার সীমাবদ্ধ করে।


5. Promise কি, এবং Fetch API কিভাবে একটি HTTP রিকোয়েস্ট বা একটি এসিঙ্ক্রোনাস অপারেশন সম্পাদন করে?
উত্তর:
Promise হলো JavaScript-এর একটি অবজেক্ট যা ভবিষ্যতে একটি নির্দিষ্ট সময়ে সফল বা ব্যর্থ হওয়ার উপর নির্ভর করে মান (value) প্রদান করে। এটি asynchronous অপারেশন সম্পন্ন করতে সাহায্য করে এবং callback function এর একটি ভালো বিকল্প।
Fetch API ব্যবহার করে আমরা HTTP রিকোয়েস্ট করতে পারি। Fetch একটি promise রিটার্ন করে যা resolve হলে response প্রদান করে এবং reject হলে error দেয়।

উদাহরণ:

fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
এখানে fetch() একটি HTTP রিকোয়েস্ট পাঠায় এবং Promise রিটার্ন করে, যা ডেটা রেসপন্সে ফিরে আসে।

এগুলো হলো আপনার ইন্টারভিউর জন্য প্রথম ৫টি প্রশ্নের বিস্তারিত উত্তর। আরও কোনো প্রশ্ন থাকলে জানাতে পারেন!






You said:
next 5
নিচে আপনার পরবর্তী ৫টি প্রশ্নের উত্তর দেওয়া হলো:

6. Arrow Functions কি, এবং এটি কেন ব্যবহার করা হয়? এর বৈশিষ্ট্য কি?
উত্তর:
Arrow Functions হলো JavaScript-এ ES6 থেকে আসা একটি সংক্ষিপ্ত ফাংশন লেখার পদ্ধতি। এটি প্রচলিত ফাংশনের চেয়ে সহজে এবং কম কোডে ফাংশন লেখার সুযোগ দেয়।
বৈশিষ্ট্য:

সিনট্যাক্স সহজ: function কিওয়ার্ড বাদ দিয়ে লেখা যায়।
this এর ভিন্ন আচরণ: সাধারণ ফাংশনের মতো এর নিজস্ব this নেই, এটি তার ঘিরে থাকা স্কোপ থেকে this ইনহেরিট করে।
ইমপ্লিসিট রিটার্ন: যদি এক লাইন কোড থাকে, তবে ব্রেস {} না দিয়ে সরাসরি রিটার্ন করা যায়।
উদাহরণ:

// Traditional function
function add(a, b) {
  return a + b;
}

// Arrow function
const add = (a, b) => a + b;
Arrow function প্রধানত ব্যবহার করা হয় এই কোড সহজ করার জন্য এবং this context এর সমস্যাগুলো এড়ানোর জন্য।

7. JavaScript-এ Prototype Chain কি এবং ইনহেরিট্যান্সের সাথে সম্পর্ক কি?
উত্তর:
Prototype Chain হলো JavaScript এর একটি ইনহেরিট্যান্স মেকানিজম, যেখানে অবজেক্টগুলো অন্য অবজেক্টের প্রপার্টি এবং মেথড ইনহেরিট করতে পারে। প্রতিটি অবজেক্টের একটি প্রোটোটাইপ থাকে, এবং যখন একটি অবজেক্টের প্রপার্টি বা মেথড খোঁজা হয়, সেটি প্রোটোটাইপ চেইন ধরে খুঁজে দেখা হয়।
ইনহেরিট্যান্সের সাথে সম্পর্ক:
JavaScript এ অবজেক্ট ইনহেরিট্যান্স প্রোটোটাইপ চেইনের মাধ্যমে কাজ করে। যদি কোনও অবজেক্টের প্রপার্টি বা মেথড সরাসরি না পাওয়া যায়, তবে এটি প্রোটোটাইপ চেইন ধরে সেই প্রপার্টি বা মেথড খুঁজে বেড়ায়।

উদাহরণ:

let animal = {
  eats: true,
  walk() {
    console.log("Animal is walking");
  }
};

let rabbit = {
  jumps: true,
  __proto__: animal  // Prototype linking
};

console.log(rabbit.eats); // true, Inherited from animal
8. Strict Mode কি এবং কীভাবে এটি ব্যবহার করা হয়? এর কোন উপকারিতা রয়েছে?
উত্তর:
Strict Mode হলো JavaScript-এর একটি ফিচার যা কোডে কিছু ভুল এবং অনিরাপদ প্র্যাকটিসকে এড়াতে সাহায্য করে। এটি use strict স্টেটমেন্ট দিয়ে চালু করা হয়। Strict Mode-এ কিছু সিনট্যাক্স এরর এবং নিরাপত্তার জন্য নিষিদ্ধ করা হয়েছে।
ব্যবহার:

"use strict";

x = 5; // ReferenceError: x is not defined (in strict mode)
উপকারিতা:

অঘোষিত ভ্যারিয়েবল ব্যবহার করা থেকে বিরত রাখে।
নির্দিষ্ট JavaScript ইঞ্জিন অপ্টিমাইজেশনে সহায়তা করে।
ডুপ্লিকেট প্রপার্টি নাম বা প্যারামিটার ব্যবহার নিষিদ্ধ করে।
9. JavaScript Event Loop কি এবং কিভাবে এটি Concurrency Model এর সাথে সম্পর্কিত?
উত্তর:
Event Loop হলো JavaScript-এর একটি মেকানিজম যা একক থ্রেডে কিভাবে অ্যাসিঙ্ক্রোনাস কোড চালায় তা পরিচালনা করে। এটি Call Stack এবং Message Queue (বা Task Queue) এর মধ্যে সমন্বয় করে।
Concurrency Model বলতে বোঝায় কিভাবে JavaScript একক থ্রেডে (single-threaded) এসিঙ্ক্রোনাস টাস্কগুলো পরিচালনা করে।

Event Loop এর কাজ:

যখন একটি অ্যাসিঙ্ক্রোনাস টাস্ক (যেমন: setTimeout, Promise, HTTP request) সম্পন্ন হয়, এটি Message Queue-তে পাঠানো হয়।
Call Stack খালি থাকলে Event Loop Message Queue থেকে কাজ নিয়ে Call Stack-এ এক্সিকিউট করে।
উদাহরণ:

console.log("Start");

setTimeout(() => {
  console.log("Asynchronous Task");
}, 0);

console.log("End");
Output:

mathematica
Copy code
Start
End
Asynchronous Task
10. Hoisting কি এবং Temporal Dead Zone কি? এটি কিভাবে কাজ করে?
উত্তর:
Hoisting হলো JavaScript এর একটি মেকানিজম যেখানে ভ্যারিয়েবল এবং ফাংশন ডিক্লারেশনগুলো তাদের স্কোপের টপে সরানো হয়, যদিও কোডে তাদের ডিক্লারেশন নিচে থাকে।
Temporal Dead Zone (TDZ) হলো let এবং const দিয়ে ডিক্লার করা ভ্যারিয়েবলগুলোর জন্য সেই সময়কাল যেখানে ভ্যারিয়েবলের ডিক্লারেশন হওয়ার আগে এক্সেস করলে রেফারেন্স এরর হয়।

Hoisting উদাহরণ:

console.log(x); // undefined (Hoisted)
var x = 10;
Temporal Dead Zone উদাহরণ:

console.log(x); // ReferenceError: Cannot access 'x' before initialization
let x = 10;
TDZ এর কারণে let ও const ভ্যারিয়েবলকে তাদের ডিক্লারেশনের আগে ব্যবহার করা যায় না।


11. Async/Await কি, এবং এটি Promises-এর সাথে কিভাবে সম্পর্কিত?
উত্তর:
Async/Await হলো JavaScript এর ES8 (ECMAScript 2017) এ যোগ করা একটি ফিচার যা asynchronous কোড লেখার একটি সহজ পদ্ধতি। এটি Promises এর ওপর ভিত্তি করে কাজ করে এবং asynchronous কোডকে আরও readable ও sequential স্টাইলে এক্সিকিউট করতে সাহায্য করে।
Async কিওয়ার্ডটি একটি ফাংশনের আগে ব্যবহার করা হয়, যা Promise রিটার্ন করে। Await কিওয়ার্ডটি সেই async ফাংশনের ভেতরে ব্যবহার করা হয়, যা একটি Promise-এর রেজাল্ট না পাওয়া পর্যন্ত অপেক্ষা করে।

উদাহরণ:

async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchData();
এখানে fetchData ফাংশনটি একটি asynchronous ফাংশন, এবং await ব্যবহার করে HTTP রিকোয়েস্টের রেসপন্স না আসা পর্যন্ত অপেক্ষা করে।

12. JavaScript-এ কি কি ডাটা টাইপ রয়েছে এবং তাদের বৈশিষ্ট্য কি?
উত্তর:
JavaScript-এ দুটি প্রধান ডাটা টাইপ রয়েছে: প্রিমিটিভ (Primitive) এবং রেফারেন্স (Reference) টাইপ।

Primitive Data Types:

String: টেক্সট ডেটা। উদাহরণ: "Hello", 'JavaScript'
Number: নাম্বার ডেটা (ইনটিজার এবং দশমিক সহ)। উদাহরণ: 42, 3.14
Boolean: true অথবা false। উদাহরণ: true, false
Undefined: একটি ভ্যারিয়েবল ডিক্লার করা হয়েছে কিন্তু ভ্যালু অ্যাসাইন করা হয়নি।
Null: ইচ্ছাকৃতভাবে খালি ভ্যালু।
Symbol: ইউনিক এবং অপরিবর্তনীয় ডেটা টাইপ যা ES6 এ যোগ করা হয়েছে।
BigInt: বড় সংখ্যার জন্য ব্যবহার হয়, যা Number টাইপের সীমার বাইরে।
Reference Data Types:

Object: কমপ্লেক্স ডেটা স্ট্রাকচার যা প্রোপার্টি এবং মেথড ধারণ করে।
Array: ordered collection of values।
Function: কোড ব্লকের একটি reusable অংশ।
Date: তারিখ এবং সময় ম্যানেজমেন্টের জন্য।
উদাহরণ:

let str = "Hello";    // String
let num = 42;         // Number
let isTrue = true;    // Boolean
let obj = { name: "Alice" };  // Object
13. JavaScript-এ this keyword কী এবং এটি কিভাবে ব্যবহৃত হয়?
উত্তর:
this হলো JavaScript-এ একটি স্পেশাল কিওয়ার্ড যা নির্দিষ্ট করে যে কোন অবজেক্টটি বর্তমানে প্রোপার্টি বা মেথড অ্যাক্সেস করছে। এটি ভিন্ন ভিন্ন কনটেক্সটে ভিন্নভাবে কাজ করতে পারে।
বিভিন্ন ক্ষেত্রে this-এর ব্যবহার:

Global Context: ব্রাউজারে this গ্লোবাল অবজেক্টকে (যেমন window) রেফার করে।
Object Method-এ: মেথডের মধ্যে this সেই অবজেক্টকে রেফার করে যার মেথড কল করা হয়েছে।
Constructor Function-এ: নতুন অবজেক্ট তৈরি করার সময় this নতুন অবজেক্টকে রেফার করে।
Arrow Functions-এ: Arrow ফাংশনে this কনটেক্সট বাইরে থেকে ইনহেরিট করে।
উদাহরণ:

const person = {
  name: "Alice",
  greet: function() {
    console.log(this.name); // 'this' refers to 'person' object
  }
};

person.greet(); // Output: Alice
14. JavaScript-এ Web APIs কি এবং কিভাবে DOM Manipulation করা হয়?
উত্তর:
Web APIs হলো ব্রাউজার দ্বারা প্রদান করা প্রি-ডিফাইন্ড ইন্টারফেস এবং ফাংশন যা আমাদের ব্রাউজারে ইন্টারেকটিভ এবং ডায়নামিক ফিচার তৈরি করতে সাহায্য করে। এগুলো মূলত জাভাস্ক্রিপ্ট দিয়ে কন্ট্রোল করা যায়। কিছু সাধারণ Web APIs হলো:

DOM (Document Object Model) API: HTML এবং CSS এর উপাদানগুলোর সাথে ইন্টারেকশন করা যায়।
Fetch API: HTTP রিকোয়েস্ট পরিচালনা করা হয়।
Geolocation API: ইউজারের লোকেশন পেতে সাহায্য করে।
DOM Manipulation:
JavaScript ব্যবহার করে DOM (Document Object Model) এ HTML উপাদানগুলিকে পরিবর্তন করা যায়।

উদাহরণ:

// একটি HTML এলিমেন্ট সিলেক্ট করা
let element = document.getElementById("myElement");

// সেটির টেক্সট পরিবর্তন করা
element.innerText = "Hello, DOM Manipulation!";

// নতুন এলিমেন্ট তৈরি করা এবং অ্যাড করা
let newElement = document.createElement("p");
newElement.innerText = "This is a new paragraph.";
document.body.appendChild(newElement);
15. JavaScript এর মডিউল সিস্টেম কি, এবং ECMAScript-6 এর Modules কিভাবে কাজ করে?
উত্তর:
JavaScript-এর মডিউল সিস্টেম মূলত কোডকে ভিন্ন ভিন্ন ফাইলে ভাগ করার একটি পদ্ধতি, যাতে কোডকে পুনর্ব্যবহার করা এবং রক্ষণাবেক্ষণ সহজ হয়। ES6 থেকে মডিউল সিস্টেমটি স্ট্যান্ডার্ডাইজ করা হয়েছে।

ECMAScript-6 মডিউল সিস্টেম:

export: মডিউল থেকে একটি ফাংশন বা ভ্যারিয়েবলকে এক্সপোর্ট করা হয় যাতে অন্য ফাইল বা মডিউলে এটি ব্যবহার করা যায়।
import: এক্সপোর্ট করা ফাংশন বা ভ্যারিয়েবল অন্য মডিউলে ব্যবহার করতে ইম্পোর্ট করা হয়।
উদাহরণ:
ফাইল 1 (math.js):

export function add(a, b) {
  return a + b;
}
ফাইল 2 (main.js):

import { add } from './math.js';
console.log(add(5, 3)); // Output: 8
ES6 মডিউল সিস্টেম কোডের মডিউলারিটি নিশ্চিত করে এবং নির্ভরশীলতা ম্যানেজ করতে সাহায্য করে।


3/3











ChatGPT can make mistakes. Check important info.
?
